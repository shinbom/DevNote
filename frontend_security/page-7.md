# CSRF(corss site request forgery)

공격자가 준비한 함정에 의해 웹 애플리케이션의 기능이 사용자 의도와 상관없이 호출되는 공격

CSRF는 XSS처럼 공격자가 마음대로 스크립트를 동작시킬 수는 없지만, 기능을 악용해 요청을 전송할 수있다.

![CSRF](./src/csrf.png)

## CSRF 대책

### 토큰을 사용

CSRF의 가장 효과적인 대책은 `토큰`을 사용하는 방법이다.

`토큰(Token)`이란 서버측 애플리케이션에서 생성되고 클라이언트와 공유되는 인증이다.

서버는 요청에 포함된 토큰과 세션에 보관된 토큰이일치하는지 확인하고, 일치하지 않으면, 잘못된 요청으로 간주한다.

### Double Submit 쿠키를 사용

`Double Submit 쿠키(이중 전송 쿠키)`

세션쿠키와 달리 랜덤 토큰 값을 가진 쿠키를 발행하고, 이 토큰을 사용해 정상적인 요청인지 확인한다.

정상 페이지에서는 폼을 전송할 때, 쿠키 내부의 토큰을 가져오고 폼의 요청 헤더와 요청 바디에 삽입한다. 서버는 폼 데이터 속 토큰과 쿠키 속 토큰의 일치 여부를 검사하여, 일치할 때에는 정상 페이지로 간주한다.

토큰이 일치하지 않거나, 존재하지 않을 떄에는 에러를 발생시킨다.

### SameSite 쿠키를 사용

쿠키 전송을 동일한 사이트로 제한하여 CSRF 공격을 막을 수 있다.

SameSIte쿠키는 개인 정보 보호를 위해 고안되었지만, CSRF대책으로도 사용할 수 있다.

```bash
Set-Cookie session=test; HttpOnly; Secure; SameSite=Lax;
```

### Origin 헤더를 사용

API를 제공하는 서버에서 Origin 헤더를 확인하면 허가되지 않은 출처의 요청을 금지할 수 있음.

### CORS를 사용

Preflight Request에서 요청 내용을 확인하면 의도하지 않은 fetch 함수와 XHR의 요청을 방지할 수 있다.

프론트엔드와 백엔드(API)가 구분되었을 떄 유용함.

> Preflight Request는 요청 횟수가 늘어남에 따라, 성능에 좋지 않다는 의견도 있음.
